<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The community-search problem and how to plan a successful cocktail party | Yining's Blog</title><meta name=keywords content="Community Search,Graph Theory,Information Retrieval"><meta name=description content="
This paper is the first paper that propose the problem of community search.
Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms
1 Motivations
Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes."><meta name=author content="Yining"><link rel=canonical href=https://yningg.github.io/Blogs/posts/research/sozio2010community/><meta name=google-site-verification content="G-R86690PBWG"><link crossorigin=anonymous href=/Blogs/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://yningg.github.io/Blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yningg.github.io/Blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yningg.github.io/Blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://yningg.github.io/Blogs/apple-touch-icon.png><link rel=mask-icon href=https://yningg.github.io/Blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yningg.github.io/Blogs/posts/research/sozio2010community/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-R86690PBWG"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R86690PBWG")}</script><meta property="og:url" content="https://yningg.github.io/Blogs/posts/research/sozio2010community/"><meta property="og:site_name" content="Yining's Blog"><meta property="og:title" content="The community-search problem and how to plan a successful cocktail party"><meta property="og:description" content=" This paper is the first paper that propose the problem of community search. Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms
1 Motivations Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-20T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-20T00:00:00+00:00"><meta property="article:tag" content="Community Search"><meta property="article:tag" content="Graph Theory"><meta property="article:tag" content="Information Retrieval"><meta property="og:image" content="https://github.com/Yningg/Blogs/tree/master/static/apple-touch-icon.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://github.com/Yningg/Blogs/tree/master/static/apple-touch-icon.png"><meta name=twitter:title content="The community-search problem and how to plan a successful cocktail party"><meta name=twitter:description content="
This paper is the first paper that propose the problem of community search.
Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms
1 Motivations
Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yningg.github.io/Blogs/posts/"},{"@type":"ListItem","position":2,"name":"The community-search problem and how to plan a successful cocktail party","item":"https://yningg.github.io/Blogs/posts/research/sozio2010community/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The community-search problem and how to plan a successful cocktail party","name":"The community-search problem and how to plan a successful cocktail party","description":" This paper is the first paper that propose the problem of community search. Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms\n1 Motivations Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes.\n","keywords":["Community Search","Graph Theory","Information Retrieval"],"articleBody":" This paper is the first paper that propose the problem of community search. Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms\n1 Motivations Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes.\n1.1 Potential Applications Social-network analysis, collaborative tagging systems, query-log analysis, biology, and others.\n2 Problem Statements Problem 1 (Generic objective function): Given an undirected (connected) graph $G = (V, E)$, a set of query nodes $Q \\subseteq V$ , and a goodness function $f$, we seek to find an induced subgraph $H = (V_H, E_H )$ of $G$, such that:\n$V_H$ contains $Q$ ($Q \\subseteq V_H$); $H$ is connected; $f(H)$ is maximized among all feasible choices for $H$. Functions that capture the density of the subgraph $H$ are considered.\n$\\frac{|V_H| \\cdot (|V_H|-1)}{2}$: since even in its simplest form this density definition leads to NP-hard problems, so this definition is not considered. The average degree $f_a(H)$ of the nodes in $H$ ($\\frac{2|E_H|}{V_H}$). However, using this measure can lead to non intuitive results. The minimum degree $f_m(H)$ of the nodes in $H$ (Considered). Though it’s sensitive to outliers, it does not suffer from the problem of attaching a non-related community. Another way to avoid the pathological situations of attaching communities that are far way from query nodes, is to set a distance constraint:\nSet $d_G(v, q)$ as the length of the shortest path between nodes $v$ and $q$ in the graph $G$. If $v$ and $q$ are in different connected components, then $d_G(v, q) = \\infty$. The distance of $v$ from the query nodes $Q$: $D_Q(G, v) = \\sum_{q \\in Q} d_G(v, q)^2$ The distance of the furthest node from $Q$: $D_Q(G) = \\max_{v \\in V(G)}{D_Q(G, v)}$ Problem 2 (Concrete Problem): Given an undirected (connected) graph $G = (V, E)$, a set of query nodes $Q \\subseteq V$, and a number $d$ to be interpreted as a distance constraint, we seek to find an induced subgraph $H = (V_H, E_H)$ of $G$, such that:\n$V_H$ contains $Q (Q \\subseteq V_H)$; $H$ is connected; $D_Q(H) \\leq d$; The minimum degree function $f_m(H)$ is maximized among all feasible choices for $H$. 3 Community Search Algorithms 3.1 Communities Without Size Constraints The GREEDY algorithm was proposed and studied by Asahiro et al. and later analyzed by Charikar, who showed that it achieves a factor 2 approximation guarantee for the densest-subgraph problem.\n*A factor 2 approximation means: The solution the algorithm gives you is guaranteed to be at least half as good as the best possible solution.\n3.1.1 GREEDY algorithm Let $G_0 = G$ For each t-th step of execution, Delete a node $u$ that has minimum degree in $G_{t−1}$ and all the edges incident to $u$ from $G_{t-1}$ to obtain graph $G_t$ Extract the connected component of $G_t$, $G_t^{’}$, which contains all query nodes $Q$ Compute $f_m(G_t^{’})$ and compare with the previous step Stop at the step if either (i) at least one of the query nodes $Q$ has minimum degree in the graph $G_{T −1}$, or (ii) the query nodes $Q$ are no longer connected. Returns the solution $G_O$ for $G_t^{’}$ where $f_m(G_t^{’})$ is maximized ($G_O = arg max {f_m(G_t^{’})| t=1,…,T-1}$). Greedy can be implemented in linear time and can be used to find an optimal solution for any monotone function.\nDrawback of GREEDY: it may return subgraphs of very large size.\n3.1.2 Generalization to monotone functions The algorithm GREEDY can be used to find an optimal solution for any monotone function.\nDefinition 1 (Monotone function) The function $f$ is monotone non-increasing if for every graph $G$ and for every induced subgraph $H$ of $G$,$f(H) \\leq f(G)$. We similarly define $f$ to be monotone non-decreasing by requiring $f(H) \\geq f(G)$.\nDefinition 2 (Node-monotone function) A function $f$ is said to be node-monotone non-increasing if for every graph $G$, for every induced subgraph $H$ of $G$, and every node $v$ in $H$, $f(H, v) \\leq f(G, v)$. We similarly define node-monotone non-decreasing functions.\nThe degree function $d(G, v)$, minimum degree function $f_m(G)$ and distance functions $D_Q(G, v)$ and $D_Q(G)$ are all monotone.\nThe generalization of the community-search problem.\nProblem 3 (Cocktail party) We are given an undirected graph $G = (V, E)$, a node-monotone non-increasing function $f: G_V × V \\rightarrow \\mathbb{R}$, as well as a set of monotone non-increasing properties $f_1, …, f_k$. We seek to find an induced subgraph $H$ of $G$ that maximizes $f$ among all induced subgraphs of $G$, and satisfies $f_1, …, f_k$. A similar problem can be defined by considering to minimize monotone non-decreasing functions.\nFor solving the Problem 3, we generalize the algorithm GREEDY to GREEDYGEN. In detail, the GREEDYGEN algorithm is described as follows:\nStart from $G_0 = G$ For each step: While $G_t$ is not empty: Check if $G_t$ satisfies all properties Return the subgraph which maximizes $f$ among all graphs $G_t$ that are constructed throughout the execution of the algorithm and satisfy all the monotone properties Check whether there is a property $f_j$ and a node $v \\in V$ such that $v$ violates $f_j$, $j = 1, …, k$. If find such a node, delete $v$ and all the incident edges of $v$ Otherwise, delete from $G$ a node $v$ such that $f(G, v)$ is minimum. The algorithm GreedyGen always returns an optimum solution for Problem 3. The exact running time of the algorithm depends on the constraints employed.\n3.2 Communities With Size Constraints If there is a specified upper bound of the size of output subgraph, the community search problem becomes NP-hard. Therefore, two simple yet effective heuristics algorithms are proposed.\nProblem 4 (Minimum degree with upper bound on the size): Given an undirected (connected) graph $G = (V_G, E_G)$, a set of query nodes $Q \\subseteq V$ , a number $d$ (distance constraint), and an integer $k$ (size constraint), we wish to find an induced subgraph $H = (V_H, E_H)$ of $G$, such that:\n$H$ contains the query nodes ($Q \\subseteq H$); $H$ is connected; $D_Q(H) \\leq d$; $|V_H| \\leq k$ ($H$ has at most $k$ nodes); The minimum degree of $H$ is maximized. The proof of NP-hardness of this problem is using the reduction to the Steiner-tree problem with unit weights.\nThe two heuristics provide a quality–efficiency trade-off: GreedyDist tries to optimize quality while GreedyFast tries to optimize efficiency.\nFirst Heuristic Algorithm: GREEDYDIST($G$, $Q$, $k$, $d$) The design principle is the simple observation that a tighter distance constraint implies smaller communities (d $\\downarrow$, size $\\downarrow$). GREEDYDIST uses the algorithm GREEDYGEN as a subroutine.\nExecute the algorithm GREEDYGEN in order to maximize the minimum degree subject to the distance constraint $d$ that is specified in input. If the query nodes are connected and the size constraint is not satisfied in the output graph, then execute GREEDYGEN again with a tighter distance bound $d’ \u003c d$ (d–). GREEDYDIST iterates executing GREEDYGEN by decreasing at each step the distance constraint, until: The size constraint is satisfied, or The query nodes become disconnected. In this case, GREEDYDIST returns the smallest graph found among all executions of GREEDYGEN that is connected. Second Heuristic Algorithm: GREEDYFAST($G$, $Q$, $k$, $d$) There is a preprocessing phase where the input graph is restricted to the $k’$ closest nodes to the query nodes. The distance of a node to the query nodes is measured using the function $D_Q$ defined in Equation (1).\nAfter this preprocessing phase, we execute GREEDY on the restricted graph formed in the preprocessing phase. The intuition for doing this is that the closer a node is to the query nodes, the more likely it belongs to the community.\nExperimental Evaluation Datasets: DBLP, tag, BIOMINE\nEfficiency metrics: running time\nEffectiveness metrics: the minimum degree $f_m$, the average degree (density) $f_a$, size and distance.\nSensitivity analysis:\nNumber of query nodes Distance between query nodes Upper bound on the number of nodes Case study: show the quality of the algorithm results\n","wordCount":"1357","inLanguage":"en","image":"https://github.com/Yningg/Blogs/tree/master/static/apple-touch-icon.png","datePublished":"2025-06-20T00:00:00Z","dateModified":"2025-06-20T00:00:00Z","author":{"@type":"Person","name":"Yining"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yningg.github.io/Blogs/posts/research/sozio2010community/"},"publisher":{"@type":"Organization","name":"Yining's Blog","logo":{"@type":"ImageObject","url":"https://yningg.github.io/Blogs/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yningg.github.io/Blogs/ accesskey=h title="Yining's Blog (Alt + H)">Yining's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yningg.github.io/Blogs/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yningg.github.io/Blogs/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yningg.github.io/Blogs/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://yningg.github.io/Blogs/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yningg.github.io/Blogs/>Home</a>&nbsp;»&nbsp;<a href=https://yningg.github.io/Blogs/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">The community-search problem and how to plan a successful cocktail party</h1><div class=post-meta><span title='2025-06-20 00:00:00 +0000 UTC'>June 20, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1357 words&nbsp;·&nbsp;Yining</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-motivations>1 Motivations</a><ul><li><a href=#11-potential-applications>1.1 Potential Applications</a></li></ul></li><li><a href=#2-problem-statements>2 Problem Statements</a></li><li><a href=#3-community-search-algorithms>3 Community Search Algorithms</a><ul><li><a href=#31-communities-without-size-constraints>3.1 Communities Without Size Constraints</a></li><li><a href=#32-communities-with-size-constraints>3.2 Communities With Size Constraints</a></li></ul></li><li><a href=#experimental-evaluation>Experimental Evaluation</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>This paper is the <strong>first</strong> paper that propose the problem of community search.
Keywords: $k$-core; Undirected graph; Size-constraints; Greedy algorithm; Heuristic Algorithms</p></blockquote><h2 id=1-motivations>1 Motivations<a hidden class=anchor aria-hidden=true href=#1-motivations>#</a></h2><p>Discovering communities in graphs and social networks has drawn a large amount of attention in recent years. Most of the work has focused on the scenario where communities need to be discovered in an a priori manner, with only reference to the input graph. However, in many application scenarios, we are interested in discovering the community defined by a given set of nodes.</p><h3 id=11-potential-applications>1.1 Potential Applications<a hidden class=anchor aria-hidden=true href=#11-potential-applications>#</a></h3><p>Social-network analysis, collaborative tagging systems, query-log analysis, biology, and others.</p><h2 id=2-problem-statements>2 Problem Statements<a hidden class=anchor aria-hidden=true href=#2-problem-statements>#</a></h2><blockquote><p><strong>Problem 1 (Generic objective function)</strong>: Given an undirected (connected) graph $G = (V, E)$, a set of query nodes $Q \subseteq V$ , and a goodness function $f$, we seek to find an induced subgraph $H = (V_H, E_H )$ of $G$, such that:</p><ul><li>$V_H$ contains $Q$ ($Q \subseteq V_H$);</li><li>$H$ is connected;</li><li>$f(H)$ is maximized among all feasible choices for $H$.</li></ul></blockquote><p>Functions that capture the <strong>density</strong> of the subgraph $H$ are considered.</p><ul><li>$\frac{|V_H| \cdot (|V_H|-1)}{2}$: since even in its simplest form this density definition leads to NP-hard problems, so this definition is not considered.</li><li>The average degree $f_a(H)$ of the nodes in $H$ ($\frac{2|E_H|}{V_H}$). However, using this measure can lead to non intuitive results.</li><li>The minimum degree $f_m(H)$ of the nodes in $H$ (Considered).<ul><li>Though it&rsquo;s sensitive to outliers, it does not suffer from the problem of attaching a non-related community.</li></ul></li></ul><p>Another way to avoid the pathological situations of attaching communities that are far way from query nodes, is to <strong>set a distance constraint</strong>:</p><ul><li>Set $d_G(v, q)$ as the length of the shortest path between nodes $v$ and $q$ in the graph $G$. If $v$ and $q$ are in different connected components, then $d_G(v, q) = \infty$.</li><li>The distance of $v$ from the query nodes $Q$: $D_Q(G, v) = \sum_{q \in Q} d_G(v, q)^2$</li><li>The distance of the furthest node from $Q$: $D_Q(G) = \max_{v \in V(G)}{D_Q(G, v)}$</li></ul><blockquote><p><strong>Problem 2 (Concrete Problem)</strong>: Given an undirected (connected) graph $G = (V, E)$, a set of query nodes $Q \subseteq V$, and a number $d$ to be interpreted as a distance constraint, we seek to find an induced subgraph $H = (V_H, E_H)$ of $G$, such that:</p><ul><li>$V_H$ contains $Q (Q \subseteq V_H)$;</li><li>$H$ is connected;</li><li>$D_Q(H) \leq d$;</li><li>The minimum degree function $f_m(H)$ is maximized among all feasible choices for $H$.</li></ul></blockquote><h2 id=3-community-search-algorithms>3 Community Search Algorithms<a hidden class=anchor aria-hidden=true href=#3-community-search-algorithms>#</a></h2><h3 id=31-communities-without-size-constraints>3.1 Communities Without Size Constraints<a hidden class=anchor aria-hidden=true href=#31-communities-without-size-constraints>#</a></h3><p><em>The GREEDY algorithm was proposed and studied by Asahiro et al. and later analyzed by Charikar, who showed that it achieves a factor 2 approximation guarantee for the densest-subgraph problem.</em></p><p>*A factor 2 approximation means: The solution the algorithm gives you is guaranteed to be at least half as good as the best possible solution.</p><h4 id=311-greedy-algorithm>3.1.1 <strong>GREEDY algorithm</strong><a hidden class=anchor aria-hidden=true href=#311-greedy-algorithm>#</a></h4><blockquote><ul><li>Let $G_0 = G$</li><li>For each t-th step of execution,<ul><li>Delete a node $u$ that has minimum degree in $G_{t−1}$ and all the edges incident to $u$ from $G_{t-1}$ to obtain graph $G_t$</li><li>Extract the connected component of $G_t$, $G_t^{&rsquo;}$, which contains all query nodes $Q$</li><li>Compute $f_m(G_t^{&rsquo;})$ and compare with the previous step</li></ul></li><li>Stop at the step if either
(i) at least one of the query nodes $Q$ has minimum degree in the graph $G_{T −1}$, or
(ii) the query nodes $Q$ are no longer connected. Returns the solution $G_O$ for $G_t^{&rsquo;}$ where $f_m(G_t^{&rsquo;})$ is maximized ($G_O = arg max {f_m(G_t^{&rsquo;})| t=1,&mldr;,T-1}$).</li></ul></blockquote><p>Greedy can be implemented in linear time and can be used to find an optimal solution for any monotone function.</p><p>Drawback of GREEDY: it may return subgraphs of very large size.</p><h4 id=312-generalization-to-monotone-functions>3.1.2 Generalization to monotone functions<a hidden class=anchor aria-hidden=true href=#312-generalization-to-monotone-functions>#</a></h4><p>The algorithm GREEDY can be used to find an optimal solution for any monotone function.</p><blockquote><p><strong>Definition 1 (Monotone function)</strong> The function $f$ is monotone non-increasing if for every graph $G$ and for every induced subgraph $H$ of $G$,$f(H) \leq f(G)$. We similarly define $f$ to be monotone non-decreasing by requiring $f(H) \geq f(G)$.</p><p><strong>Definition 2 (Node-monotone function)</strong> A function $f$ is said to be node-monotone non-increasing if for every graph $G$, for every induced subgraph $H$ of $G$, and every node $v$ in $H$, $f(H, v) \leq f(G, v)$. We similarly define node-monotone non-decreasing functions.</p></blockquote><p>The degree function $d(G, v)$, minimum degree function $f_m(G)$ and distance functions $D_Q(G, v)$ and $D_Q(G)$ are all monotone.</p><p>The generalization of the community-search problem.</p><blockquote><p><strong>Problem 3 (Cocktail party)</strong> We are given an undirected graph $G = (V, E)$, a node-monotone non-increasing function $f: G_V × V \rightarrow \mathbb{R}$, as well as a set of monotone non-increasing properties $f_1, &mldr;, f_k$. We seek to find an induced subgraph $H$ of $G$ that maximizes $f$ among all induced subgraphs of $G$, and satisfies $f_1, &mldr;, f_k$. A similar problem can be defined by considering to minimize monotone non-decreasing functions.</p></blockquote><p>For solving the Problem 3, we generalize the algorithm GREEDY to GREEDYGEN. In detail, the GREEDYGEN algorithm is described as follows:</p><blockquote><ul><li>Start from $G_0 = G$</li><li>For each step:<ul><li>While $G_t$ is not empty:<ul><li>Check if $G_t$ satisfies all properties<ul><li>Return the subgraph which maximizes $f$ among all graphs $G_t$ that are constructed throughout the execution of the algorithm and satisfy all the monotone properties</li></ul></li><li>Check whether there is a property $f_j$ and a node $v \in V$ such that $v$ violates $f_j$, $j = 1, &mldr;, k$.<ul><li>If find such a node, delete $v$ and all the incident edges of $v$</li><li>Otherwise, delete from $G$ a node $v$ such that $f(G, v)$ is minimum.</li></ul></li></ul></li></ul></li></ul></blockquote><p>The algorithm GreedyGen always returns an optimum solution for Problem 3. The exact running time of the algorithm depends on the constraints employed.</p><h3 id=32-communities-with-size-constraints>3.2 Communities With Size Constraints<a hidden class=anchor aria-hidden=true href=#32-communities-with-size-constraints>#</a></h3><p>If there is a specified upper bound of the size of output subgraph, the community search problem becomes NP-hard. Therefore, two simple yet effective heuristics algorithms are proposed.</p><blockquote><p><strong>Problem 4 (Minimum degree with upper bound on the size)</strong>: Given an undirected (connected) graph $G = (V_G, E_G)$, a set of query nodes $Q \subseteq V$ , a number $d$ (distance constraint), and an integer $k$ (size constraint), we wish to find an induced subgraph $H = (V_H, E_H)$ of $G$, such that:</p><ul><li>$H$ contains the query nodes ($Q \subseteq H$);</li><li>$H$ is connected;</li><li>$D_Q(H) \leq d$;</li><li>$|V_H| \leq k$ ($H$ has at most $k$ nodes);</li><li>The minimum degree of $H$ is maximized.</li></ul></blockquote><p><em>The proof of NP-hardness of this problem is using the reduction to the <strong>Steiner-tree problem with unit weights</strong>.</em></p><p>The two heuristics provide a quality–efficiency trade-off: GreedyDist tries to optimize quality while GreedyFast tries to optimize efficiency.</p><h4 id=first-heuristic-algorithm-greedydistg-q-k-d>First Heuristic Algorithm: GREEDYDIST($G$, $Q$, $k$, $d$)<a hidden class=anchor aria-hidden=true href=#first-heuristic-algorithm-greedydistg-q-k-d>#</a></h4><p>The design principle is the simple observation that a tighter distance constraint implies smaller communities (d $\downarrow$, size $\downarrow$). GREEDYDIST uses the algorithm GREEDYGEN as a subroutine.</p><blockquote><ul><li>Execute the algorithm GREEDYGEN in order to maximize the minimum degree subject to the distance constraint $d$ that is specified in input.</li><li>If the query nodes are connected and the size constraint is not satisfied in the output graph, then execute GREEDYGEN again with a tighter distance bound $d&rsquo; &lt; d$ (d&ndash;).</li><li>GREEDYDIST iterates executing GREEDYGEN by decreasing at each step the distance constraint, until:<ul><li>The size constraint is satisfied, or</li><li>The query nodes become disconnected. In this case, GREEDYDIST returns the smallest graph found among all executions of GREEDYGEN that is connected.</li></ul></li></ul></blockquote><h4 id=second-heuristic-algorithm-greedyfastg-q-k-d>Second Heuristic Algorithm: GREEDYFAST($G$, $Q$, $k$, $d$)<a hidden class=anchor aria-hidden=true href=#second-heuristic-algorithm-greedyfastg-q-k-d>#</a></h4><p>There is a preprocessing phase where the input graph is restricted to the $k&rsquo;$ closest nodes to the query nodes. The distance of a node to the query nodes is measured using the function $D_Q$ defined in Equation (1).</p><p>After this preprocessing phase, we execute GREEDY on the restricted graph formed in the preprocessing phase. The intuition for doing this is that the closer a node is to the query nodes, the more likely it belongs to the community.</p><h2 id=experimental-evaluation>Experimental Evaluation<a hidden class=anchor aria-hidden=true href=#experimental-evaluation>#</a></h2><p><strong>Datasets</strong>: DBLP, tag, BIOMINE</p><p><strong>Efficiency metrics</strong>: running time</p><p><strong>Effectiveness metrics</strong>: the minimum degree $f_m$, the average degree (density) $f_a$, size and distance.</p><p><strong>Sensitivity analysis</strong>:</p><ul><li>Number of query nodes</li><li>Distance between query nodes</li><li>Upper bound on the number of nodes</li></ul><p><strong>Case study</strong>: show the quality of the algorithm results</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yningg.github.io/Blogs/tags/community-search/>Community Search</a></li><li><a href=https://yningg.github.io/Blogs/tags/graph-theory/>Graph Theory</a></li><li><a href=https://yningg.github.io/Blogs/tags/information-retrieval/>Information Retrieval</a></li></ul><nav class=paginav><a class=prev href=https://yningg.github.io/Blogs/posts/research/sentiment_analysis/><span class=title>« Prev</span><br><span>Recent Advances on Sentiment Analysis</span>
</a><a class=next href=https://yningg.github.io/Blogs/posts/books/puppymoney/><span class=title>Next »</span><br><span>Reading Notes: 《小狗钱钱》</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on x" href="https://x.com/intent/tweet/?text=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party&amp;url=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f&amp;hashtags=CommunitySearch%2cGraphTheory%2cInformationRetrieval"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f&amp;title=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party&amp;summary=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party&amp;source=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f&title=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on whatsapp" href="https://api.whatsapp.com/send?text=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party%20-%20https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on telegram" href="https://telegram.me/share/url?text=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party&amp;url=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The community-search problem and how to plan a successful cocktail party on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20community-search%20problem%20and%20how%20to%20plan%20a%20successful%20cocktail%20party&u=https%3a%2f%2fyningg.github.io%2fBlogs%2fposts%2fresearch%2fsozio2010community%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=nejckorasa/nejckorasa.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyNzQ0NDI2MTE=" data-category=Announcements data-category-id=DIC_kwDOEFupc84CpfL- data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://yningg.github.io/Blogs/>Yining's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>